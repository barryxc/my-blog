---
title: readelf、nm以及objdump的作用与区别
date: 2025-08-07 17:53:22
tags:
category: c++
---

#### readelf、nm 和 objdump 的作用与区别
##### 1. readelf
- 作用
  用于解析和显示 ELF 格式文件（如可执行文件、动态库、core dump）的详细结构信息，包括：
  - ELF Header（文件类型、入口地址、节头表偏移等）。
  - Program Headers（内存段类型、权限、文件偏移等）。
  - Section Headers（节名称、类型、大小等）。
  - 符号表（`.symtab`）、重定位表（`.rel.*`）等调试信息。
- 示例命令
```
readelf -a a.out          # 显示所有信息
readelf -S a.out          # 仅显示节头表
readelf -l a.out          # 仅显示程序头表
```
- 优点
  - 输出信息全面，适合分析 ELF 文件的底层结构。
  - 支持直接解析二进制文件，无需依赖其他工具。
- 缺点
  - 输出内容较为原始，需手动筛选关键信息。
  - 不支持反汇编代码段内容。
##### 2. nm
- 作用
  显示 ELF 文件中的符号表信息，包括：
  - 符号名称、地址、类型（如函数、全局变量、未初始化变量等）。
  - 符号的可见性（如全局符号 `T`、本地符号 `t`）。
- 示例命令
```
nm a.out                  # 显示所有符号
nm -D /lib64/ld-linux-x86-64.so.2  # 显示动态库符号
```
- 优点
  - 快速定位符号地址和类型，适合调试符号冲突或未定义引用问题。
  - 输出简洁，适合脚本化处理。
- 缺点
  - 仅显示符号表，无法查看内存布局或节信息。
  - 不支持反汇编或动态链接信息分析。
##### 3. objdump
- 作用
  提供更全面的 ELF 文件分析功能，包括：
  - 反汇编代码段（`.text` 节）。
  - 显示节头表、程序头表、动态段（`.dynamic`）等。
  - 解析重定位信息（`.rel.*` 节）。
- 示例命令
```
objdump -d a.out          # 反汇编代码段
objdump -x a.out          # 显示所有头信息和节内容
objdump -R a.out          # 显示动态重定位信息
```
- 优点
  - 支持反汇编，适合分析代码逻辑或机器指令。
  - 输出格式灵活，可结合 `-S` 选项混合显示汇编和源码（需调试信息）。
- 缺点
  - 反汇编可能因优化选项（如 `-O2`）导致代码难以阅读。
  - 输出信息量大，需结合过滤条件（如 `-j .text`）缩小范围。
#### 三者对比总结
| 工具    | 核心功能           | 适用场景                   | 优势                     | 局限性                     |
| ------- | ------------------ | -------------------------- | ------------------------ | -------------------------- |
| readelf | 解析 ELF 结构信息  | 分析文件头、节头、程序头   | 信息全面，直接解析二进制 | 输出原始，需手动筛选       |
| nm      | 显示符号表         | 调试符号冲突、未定义引用   | 快速定位符号地址和类型   | 仅限符号表，无代码分析能力 |
| objdump | 反汇编、节内容解析 | 代码逻辑分析、动态链接调试 | 支持反汇编和混合源码显示 | 输出信息量大，需过滤条件   |
#### 选择建议
- 分析 ELF 文件结构 → 使用 `readelf`。
- 调试符号问题 → 使用 `nm`。
- 反汇编或动态链接分析 → 使用 `objdump`。
- 综合调试 → 结合三者（如 `readelf` 查看结构，`nm` 定位符号，`objdump` 反汇编）。
